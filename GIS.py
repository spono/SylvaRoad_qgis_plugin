"""
/***************************************************************************
 GIS
                                 A QGIS plugin
 This is an adaption of the SylvaRoad app for in qgis uses
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-03-05
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Cosylval
        email                : yoann.zenner@viacesi.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import numpy as np
from shapely.geometry import Point,LineString
from osgeo import gdal,ogr,osr
import os
from qgis.PyQt.QtCore import QCoreApplication
from .functions_np import calculate_polar,Distplan,basic_calc,diff_az,calculate_azimut,Distplan,get_pix_bufgoal_and_update,calc_init,build_radius
import heapq
from .console import printor




###############################################################################
### Functions
###############################################################################


class PriorityQueue:
    def __init__(self):
        self.elements = []
    
    def empty(self):
        return len(self.elements) == 0    
   
    def put(self, item, theo_d,d_to_end):
        heapq.heappush(self.elements, (theo_d,d_to_end, item))
        
    def get(self):
        return heapq.heappop(self.elements)[2]     


def Astar_buf_wp(segments,Slope,IdVois, Id, Tab_corresp,IdPix,Az,Dist,
                min_slope,max_slope,penalty_xy,penalty_z,Dist_to_End,
                Local_Slope,Perc_Slope,Csize,dtm,max_diff_z,
                trans_slope_all,newObs,angle_hairpin,Lmax_ab_sl,Radius,
                D_neighborhood,prop_sl_max=0.25,tal=1.5,lpla=4):
    
    """Builds a neighborhood table based on specified parameters and input data.

    This function constructs a neighborhood table for each pixel in the provided digital
    terrain model (DTM). The neighborhood is defined within a specified distance neighborhood
    radius (D_neighborhood) around each pixel. Neighboring pixels are included if they meet
    certain criteria, such as being within the specified slope range (min_slope to max_slope).

    :param D_neighborhood: The radius of the neighborhood in meters.
    :type D_neighborhood: float

    :param Csize: The size of each pixel in meters.
    :type Csize: float

    :param dtm: The digital terrain model data.
    :type dtm: numpy.ndarray

    :param Obs: The obstacle data.
    :type Obs: numpy.ndarray

    :param min_slope: The minimum slope threshold for including neighboring pixels.
    :type min_slope: float

    :param max_slope: The maximum slope threshold for including neighboring pixels.
    :type max_slope: float

    :return: A tuple containing:
             - The table of neighboring pixel indices for each pixel.
             - The table of neighboring pixel coordinates for each pixel.
             - The correspondence table mapping each pixel to its neighbors.
             - The table of pixel indices.
             - The slope values between each pixel and its neighbors.
             - The distances to each neighbor.
             - The azimuths to each neighbor.
    :rtype: tuple

    :raises: None
    """

    #1. Create neighborhood matrix with azimut and distance 
    nbpart = len(segments)
    test=1    
    max_slope_change = 2.*max(min_slope,max_slope) 
    max_slope_hairpin= max_slope*0.5+2 #From observation on previous simulation
    max_hairpin_angle = 180-max_slope_hairpin*0.01/tal*180*(1+1/(2*np.pi)) #Distance on the slope between roads
    max_hairpin_angle -= lpla*360/(2*np.pi*2*Radius)#Additional Distance corresponding to platform width 
    Obs2 = np.int8(Perc_Slope>trans_slope_all)
    nbpix = Tab_corresp.shape[0]    
    Best = np.zeros((nbpix,11),dtype=np.float32) 
    Best[:,0]=-1
    Best[:,6]=-1
    Best[:,1]=10000000  
    Best[:,9]=10000000  
    idseg=0
    seg = segments[0]
    yS,xS = seg[0]   
    Dtocp = Dist_to_End[yS,xS]
    
    #idcel cost_so_far Dplan Slope_from az_from came_from hairpin_from Lsl idseg Dtocp ishairpin 
    #0     1           2     3          4       5         6            7   8     9     10              
     
    seg= segments[0]
    yI,xI = seg[0]
    idStart = IdPix[yI,xI]
    Best[idStart]=idStart,0,0,0,-1,-1,0,0,0,Dist_to_End[yI,xI],0
    frontier = PriorityQueue()
    key_frontier= {}
    frontier.put(idStart, Dist_to_End[yI,xI],Dist_to_End[yI,xI]) 
    difbuf = 0   
    Dcheck = min(400,Dtocp)
    
    for idseg,seg in enumerate(segments):    
        if not test:
            break
        yS,xS = seg[0]
        yE,xE = goal= seg[1]        
        bufgoal = max(0,seg[2])  
        idend = IdPix[yE,xE]
        
        #2. initiate search   
        str_process = " %"
        test=0
        loop=0
        mindist_to_end = 10000000
        min_cost=10000000
        prev_cost = 0
        add_cost = min(max(20*bufgoal,10*max(penalty_xy,penalty_z))+difbuf,max(difbuf,4000))
                                 
        if segments[-1][1]==goal:
            take_dtoend = 1
            Dtocp = Dist_to_End[yS,xS]
        else:
            take_dtoend = 0
            Dtocp =  Distplan(yS,xS,yE,xE)*Csize  
        
        endreach = 0
        
        #3. search best path   
        while not frontier.empty() and prev_cost<min_cost:
            av = min(int(100*(1-mindist_to_end/Dtocp)),99)                     
            if loop>0:
                printor(6, idseg+1, av, str_process)        
                      
            
            idcurrent = frontier.get()  
            prev_cost=Best[idcurrent,1]
            if idcurrent==idend:
                min_cost=Best[idend,1]+add_cost
                endreach = 1
            
            if endreach:
                if  Distplan(Tab_corresp[idcurrent,0],Tab_corresp[idcurrent,1],yE,xE)*Csize > Dcheck:
                    continue
            
            nbptbef = Best[idcurrent,8]
            if nbptbef==0:
                Best,add_to_frontier,mindist_to_end= calc_init(idcurrent,Id,IdVois,Slope,
                                                                 Best,Tab_corresp,Az,Dist,
                                                                 newObs,Obs2,Dist_to_End,dtm,            
                                                                 Csize,max_diff_z,D_neighborhood,Lmax_ab_sl,
                                                                 take_dtoend,yE,xE,mindist_to_end)
                
            
            else:
                yc,xc =Tab_corresp[idcurrent,0], Tab_corresp[idcurrent,1]                 
                Best,add_to_frontier,mindist_to_end =  basic_calc(idcurrent,Id,IdVois,Slope,
                                                                    Best,Tab_corresp,Az,Dist,
                                                                    newObs,Obs2,Dist_to_End,dtm,Local_Slope[yc,xc]/100.,           
                                                                    Csize,max_diff_z,D_neighborhood,Lmax_ab_sl,
                                                                    take_dtoend,yE,xE,mindist_to_end,prop_sl_max,
                                                                    angle_hairpin,Radius,penalty_xy,penalty_z,
                                                                    max_slope_change,max_hairpin_angle)    
                
            for idvois in add_to_frontier:                 
                theo_d = round(Best[idvois,1]+Best[idvois,9],1)
                dtocp = round(Best[idvois,9],1)
                if (idvois,theo_d,dtocp) not in key_frontier:
                    frontier.put(idvois,theo_d,dtocp)  
                    key_frontier[(idvois,theo_d,dtocp) ]=1    
                
            loop+=1       
        
        av=100
        printor(6, idseg+1, av, str_process)
 
  
        
        #4. Identify pixels within bufgoal and add them to new search               
        if idseg<nbpart-1:
            #There is a segment after
            yE,xE=segments[idseg+1][1]        
        Best,add_to_frontier,keep =  get_pix_bufgoal_and_update(Best,Tab_corresp,
                                                                  bufgoal,idStart,
                                                                  Csize,yE, xE)        
        nbok = add_to_frontier.shape[0]
        #5. Check if checkpoint is reached
        test=1
        if nbok==0:
            test=0
            printor(7, idseg+2)
            break            
        tp = keep==0
        Best[tp]=0        
        Best[tp,0]=-1
        Best[tp,6]=-1
        Best[tp,1]=10000000 
        Best[tp,9]=10000000 
        
        
        #6.a if not last segment
        printor(8,idseg+2)

        if idseg<nbpart-1:   
            difbuf = np.max(Best[add_to_frontier,1])-np.min(Best[add_to_frontier,1])
            key_frontier= {}
            frontier = PriorityQueue()
            for idvois in add_to_frontier:                 
                theo_d = round(Best[idvois,1],1)
                dtocp = round(Best[idvois,9],1)
                if (idvois,theo_d,dtocp) not in key_frontier:
                    frontier.put(idvois,theo_d,dtocp)  
                    key_frontier[(idvois,theo_d,dtocp) ]=1  
        #6.b if last segment 
        else:
            if nbok>1:            
                Buf = Best[add_to_frontier]              
                ind = np.lexsort([-Buf[:,6],Buf[:,9]])
                goal = int(Buf[ind][0][0])
            else:
                goal = add_to_frontier[0]
                                     
    #Reconstruct path                
    Path=None
    if test:        
        Path =reconstruct_path(goal, idStart, Best,Tab_corresp)
        Path[1:,-1]-=Path[:-1,-1]  
    else:
        ind = np.argmin(Best[:,9])
        Path =reconstruct_path(ind, idStart, Best,Tab_corresp)
        Path[1:,-1]-=Path[:-1,-1]  
        
    
    return Path,test


def test_point_within(segments, dtm, obs, id_tron, res_process):
    """Check if points in segments are within the bounds of the digital terrain model (DTM)
    and whether they fall within allowed regions or obstacles.

    :param segments: List of segments containing points.
    :type segments: list

    :param dtm: Digital Terrain Model (DTM).
    :type dtm: numpy.ndarray

    :param obs: Array representing the allowed regions and obstacles.
    :type obs: numpy.ndarray

    :param id_tron: Tronçon ID.
    :type id_tron: int

    :param res_process: Result process string.
    :type res_process: str

    :return: Tuple containing a test flag, result process string, and end point.
    :rtype: tuple
    """
    nrows, ncols = obs.shape
    txt = ""
    txt_deb = QCoreApplication.translate("MainWindow", "\n    Tronçon n°") 
    txt_deb += f"{int(id_tron)}: "
    
    try:
        end = segments[-1][1]  # Last point in the segments list
        # Check initial point
        start = segments[0][0]
        if not (0 <= start[0] < nrows and 0 <= start[1] < ncols):
            txt2 = QCoreApplication.translate("MainWindow", "Le point initial n'est pas dans l'emprise du MNT")
            txt += txt2
            res_process += txt2
        else:
            if obs[start] == 2:
                txt2 = txt_deb + QCoreApplication.translate("MainWindow", "Le point initial n'est pas dans le parcellaire autorisé")
                txt += txt2
                res_process += txt2
            elif obs[start] == 1:
                if dtm[start] == -9999:
                    txt2 = txt_deb + QCoreApplication.translate("MainWindow", "Le point initial n'a pas de valeur MNT valide")
                else:
                    txt2 = txt_deb + QCoreApplication.translate("MainWindow", "Le point initial est sur un obstacle")
                txt += txt2
                res_process += txt2

        # Check intermediate points
        if len(txt) > 0:
            txt_deb = "\n                  "
        for i, (start, _) in enumerate(segments[1:], start=1):
            txt_pt = QCoreApplication.translate("MainWindow", "Le point de passage ID_POINT") 
            txt_pt += f"{i+1}"
            if not (0 <= start[0] < nrows and 0 <= start[1] < ncols):
                txt2 = txt_deb + txt_pt + QCoreApplication.translate("MainWindow", " n'est pas dans l'emprise du MNT")
                txt += txt2
                res_process += txt2
            else:
                if obs[start] == 2:
                    txt2 = txt_deb + txt_pt + QCoreApplication.translate("MainWindow", " n'est pas dans le parcellaire autorisé")
                    txt += txt2
                    res_process += txt2
                elif obs[start] == 1:
                    if dtm[start] == -9999:
                        txt2 = txt_deb + txt_pt + QCoreApplication.translate("MainWindow", " n'a pas de valeur MNT valide")
                    else:
                        txt2 = txt_deb + txt_pt + QCoreApplication.translate("MainWindow", " est sur un obstacle")
                    txt += txt2
                    res_process += txt2

        # Check final point
        if len(txt) > 0:
            txt_deb = "\n                  "
        if not (0 <= end[0] < nrows and 0 <= end[1] < ncols):
            txt2 = txt_deb + QCoreApplication.translate("MainWindow", "Le point final n'est pas dans l'emprise du MNT")
            txt += txt2
            res_process += txt2
        else:
            if obs[end] == 2:
                txt2 = txt_deb + QCoreApplication.translate("MainWindow", "Le point final n'est pas dans le parcellaire autorisé")
                txt += txt2
                res_process += txt2
            elif obs[end] == 1:
                if dtm[end] == -9999:
                    txt2 = txt_deb + QCoreApplication.translate("MainWindow", "Le point final n'a pas de valeur MNT valide")
                else:
                    txt2 = txt_deb + QCoreApplication.translate("MainWindow", "Le point final est sur un obstacle")
                txt += txt2
                res_process += txt2

    except IndexError:
        txt = QCoreApplication.translate("MainWindow", "    Tronçon n°")
        txt += f"{int(id_tron)}"
        txt += QCoreApplication.translate("MainWindow", ": Il faut au minimum deux points pour réaliser l'analyse")
        res_process += txt
        end = ""

    if len(txt) > 0:
        test = 0
        printor(2,txt)
        res_process += '\n'
    else:
        test = 1
    
    return test, res_process, end


def get_id_lacets(Path,angle_hairpin):
    
    """Identifies and categorizes loops (lacets) in a path based on azimuth angles.

    :param Path: Array containing path data.
    :type Path: numpy.ndarray
    :param angle_hairpin: Threshold angle for considering a loop as a hairpin.
    :type angle_hairpin: float

    :return: Array containing IDs and types of identified loops.
    :rtype: numpy.ndarray

    :raises: None
    """
    id_lacet_classique = []    
    for i,pt in enumerate(Path[1:-1]):
        az1 = pt[3]
        az2 = Path[i+2,3]
        difangle1 =  diff_az(az1,az2)
        if difangle1 > angle_hairpin:
            id_lacet_classique.append(i+1)   
            
    id_lacet_bis = [] 
    dif_angle = []
    for i,pt in enumerate(Path[1:-1]):
        if i in id_lacet_classique:
            continue
        if i-1 in id_lacet_classique:
            continue
        if i+1 in id_lacet_classique:
            continue
        if i+2 in id_lacet_classique:
            continue        
       
        if i+3<Path.shape[0]:
            az1 = pt[3]
            az2 = Path[i+2,3]
            difangle1 = diff_az(az1,az2)
            if abs((az2-difangle1)%360-az1)<0.1:
                difangle1*=-1
            az3 = Path[i+3,3]
            difangle2 =  diff_az(az2,az3)
            if abs((az3-difangle2)%360-az2)<0.1:
                difangle2*=-1          
            
            if i in id_lacet_bis:                
                idx = id_lacet_bis.index(i)
                if dif_angle[idx]> abs(difangle1+difangle2):
                    continue
                else:
                    del dif_angle[idx],id_lacet_bis[idx]
                
            if i-1 in id_lacet_bis:
                idx = id_lacet_bis.index(i-1)
                if dif_angle[idx]> abs(difangle1+difangle2):
                    continue
                else:
                    del dif_angle[idx],id_lacet_bis[idx]
                
            if abs(difangle1+difangle2) > angle_hairpin:
                dif_angle.append(abs(difangle1+difangle2))
                id_lacet_bis.append(i+1)
                      
    lacets = np.zeros((len(id_lacet_bis)+len(id_lacet_classique),2),dtype=np.int32)
    lacets[:len(id_lacet_bis),0]=id_lacet_bis
    lacets[:len(id_lacet_bis),1]=2
    lacets[len(id_lacet_bis):,0]=id_lacet_classique
    lacets[len(id_lacet_bis):,1]=1
    ind = np.lexsort([lacets[:,1],lacets[:,0]])
    
    return lacets[ind]


def trace_lace(Path,R,Extent,Csize,angle_hairpin,dtm,coefplat=2):   
    
    """Traces loops (lacets) along a path based on azimuth angles and surface characteristics.

    :param Path: Array containing path data.
    :type Path: numpy.ndarray

    :param R: Radius of the loop.
    :type R: float

    :param Extent: Extent of the area.
    :type Extent: tuple

    :param Csize: Cell size.
    :type Csize: float

    :param angle_hairpin: Threshold angle for considering a loop as a hairpin.
    :type angle_hairpin: float

    :param dtm: Digital Terrain Model (DTM) data.
    :type dtm: numpy.ndarray

    :param coefplat: Coefficient for adjusting the loop's surface characteristics, defaults to 2.
    :type coefplat: int, optional

    :return: Array containing traced path data with added loop details.
    :rtype: numpy.ndarray

    :raises: None
    """
    lacets = get_id_lacets(Path,angle_hairpin)
    
    coords = build_radius(R)
    x0,y0=Extent[0]+0.5*Csize,Extent[3]-0.5*Csize
    newPath = np.zeros((Path.shape[0],Path.shape[1]+3))
    newPath[:,0:7] = Path[:,0:7]
    for i,pt in enumerate(Path):
        newPath[i,9]=dtm[int(pt[0]),int(pt[1])]   
      
    Path=np.copy(newPath)
    Path[:,0]=y0-Path[:,0]*Csize
    Path[:,1]=Path[:,1]*Csize+x0 
    for lac in lacets:
        Path[lac[0],7]=lac[0]
        Path[lac[0],8]=lac[1]
            
    for lac in lacets: 
        line_lac,method = lac 
        try:
            line_lac=np.argwhere(Path[:,7]==line_lac)[0,0]             
        except:
            continue

        if method==1:
            #Angle > hairpin between 2 segments / Center at turn
            B = Point(Path[line_lac,1], Path[line_lac,0])
        else:
            #Angle > hairpin between 3 segments 
            #Center on the middle point of the segment
            A = Point(Path[line_lac,1], Path[line_lac,0])
            D = Point(Path[line_lac+1,1], Path[line_lac+1,0])           
            B = Point(0.5*A.x+0.5*D.x,0.5*A.y+0.5*D.y)            
         
        RingR15 = B.buffer(R*coefplat).boundary
        #find intersection before
        #A = Point(Path[line_lac-1,1], Path[line_lac-1,0])  
        cutpt_bef = 0
        check_int=False
        while not check_int and cutpt_bef*Csize<R*(coefplat+0.5):   
            cutpt_bef+=1
            vois = []
            for ide in range(max(0,line_lac-cutpt_bef),line_lac+1):
                vois.append(Point(Path[ide,1], Path[ide,0]))
            RoadBef = LineString(vois)
            check_int = RingR15.intersects(RoadBef)
            
        if check_int:
            intbef = RingR15.intersection(RoadBef)
            x1 = Point(intbef.coords[0]) 
            x,y = Path[line_lac-cutpt_bef+1,1],Path[line_lac-cutpt_bef+1,0]
            D =  Distplan(y, x, x1.y, x1.x)
            x1z = Path[line_lac-cutpt_bef+1,9]-Path[line_lac-cutpt_bef+1,2]/100*D
        else:                
            continue
                
        #find intersection after
        #C = Point(Path[line_lac+1,1], Path[line_lac+1,0])
        cutpt_aft = 0
        check_int=False
        while not check_int and cutpt_aft*Csize<R*(coefplat+0.5):   
            cutpt_aft+=1
            vois = []
            for ide in range(line_lac,min(Path.shape[0],line_lac+cutpt_aft+1)):
                vois.append(Point(Path[ide,1], Path[ide,0]))
            RoadAft = LineString(vois)
            check_int = RingR15.intersects(RoadAft)
            
        if check_int:
            intaft = RingR15.intersection(RoadAft)
            x2 = Point(intaft.coords[0])
            x,y = Path[line_lac+cutpt_aft,1],Path[line_lac+cutpt_aft,0]
            D =  Distplan(y, x, x2.y, x2.x)
            x2z = Path[line_lac+cutpt_aft,9]-Path[line_lac+cutpt_aft,2]/100*D
        else:                
            continue
        
        #get turn direction
        azfrom = Path[line_lac,3]
        azto = Path[line_lac+1,3]
        dif =  diff_az(azfrom,azto)
        sign=1
        if abs((azto-dif)%360-azfrom)<0.1:
            sign*=-1
               
        #get point on radius                
        pol1 = calculate_polar(B.x,B.y,x1.x,x1.y)
        pol2 = calculate_polar(B.x,B.y,x2.x,x2.y)        
                  
        diff_angle = 360- diff_az(pol2,pol1)  
               
        nbpt = int(diff_angle/45.) 
        start = int(0.5*(360-(nbpt-1)*45- diff_az(pol2,pol1))+0.5)  
        pt_list = []
        pol = int((pol1+sign*start)%360+0.5)        
        xbef,ybef=x1.x,x1.y
        x,y=coords[pol,1]+B.x,coords[pol,2]+B.y
        D = []
        D.append( Distplan(y, x, ybef,xbef))       
        pt_list.append([x,y])
        ybef,xbef=y,x
        for i in range(1,nbpt):            
            pol = int((pol1+i*sign*45+sign*start)%360)
            x,y=coords[pol,1]+B.x,coords[pol,2]+B.y
            pt_list.append([x,y])
            D.append( Distplan(y, x, ybef,xbef))
            xbef,ybef=x,y
        D.append( Distplan(x2.y, x2.x, ybef,xbef))
        Dcum=np.sum(D)  
        sl = (x2z-x1z) /  Dcum   
        newPath = np.zeros((Path.shape[0]+len(pt_list)+3-cutpt_bef-cutpt_aft,Path.shape[1]))
        newPath[0:line_lac-cutpt_bef+1]= Path[0:line_lac-cutpt_bef+1]
        newPath[line_lac-cutpt_bef+1,0:2] = x1.y,x1.x            
        newPath[line_lac-cutpt_bef+1,7:9] = lac[0],0
        newPath[line_lac-cutpt_bef+1,9] = x1z 
        newPath[line_lac-cutpt_bef+1,2] = Path[line_lac-cutpt_bef+1,2]
        for i,pt in enumerate(pt_list):
            newPath[line_lac-cutpt_bef+2+i,0:2]=pt[1],pt[0]
            newPath[line_lac-cutpt_bef+2+i,7:9] = lac[0],1
            newPath[line_lac-cutpt_bef+2+i,2] = sl*100
            newPath[line_lac-cutpt_bef+2+i,9] = x1z+sl*np.sum(D[:i+1])
        newPath[line_lac-cutpt_bef+3+i,0:2]=x2.y,x2.x
        newPath[line_lac-cutpt_bef+3+i,9]=x2z
        newPath[line_lac-cutpt_bef+3+i,2]=sl*100
        newPath[line_lac-cutpt_bef+3+i,7:9] = lac[0],1
        newPath[line_lac-cutpt_bef+4+i:]=Path[line_lac+cutpt_aft:] 
    
        Path=np.copy(newPath)
        
    
    #Complete table
    #Y X SLOPE AZ DPLAN D3D Z LSL
    #0 1 2     3  4     5   6 7
    keep = np.ones((Path.shape[0],),dtype=np.uint8)
    for i in range(1,Path.shape[0]):
        y,x = Path[i,0:2]
        y1,x1 = Path[i-1,0:2]
        Path[i,4]=np.sqrt((x1-x)**2+(y1-y)**2)
        if Path[i,4]!=0:
            Path[i,3]=calculate_azimut(x1,y1,x,y)  
        else:
            keep[i]=0
    tp = keep==1
    Path = Path[tp] 
       
    return Path
  

def check_field(filename,fieldname):    

    """Checks if a specific field exists in the attribute table of a vector dataset.

    :param filename: Path to the vector dataset.
    :type filename: str
    :param fieldname: Name of the field to check.
    :type fieldname: str

    :return: 0 if the field does not exist, 1 if the field exists and has consistent values across all features, 
             2 if the field exists but has missing values in some features.
    :rtype: int

    :raises: None
    """
    test=0
    source_ds = ogr.Open(filename)
    layer = source_ds.GetLayer()    
    ldefn = layer.GetLayerDefn()
    for n in range(ldefn.GetFieldCount()):
        fdefn = ldefn.GetFieldDefn(n)
        if fdefn.name==fieldname:
            test=1
            break
    if test:
        featureCount = layer.GetFeatureCount()
        vals = []
        for feat in layer:
            val = feat.GetField(fieldname)
            if val is not None:
                vals.append(feat.GetField(fieldname))
        source_ds.Destroy() 
        if len(vals)!=featureCount:
            test=2
    
    return test


def raster_get_info(in_file_name):
    
    """Retrieves information about a raster dataset.

    :param in_file_name: Path to the input raster file.
    :type in_file_name: str

    :return: Names and corresponding values of important raster parameters,
             spatial reference of the raster dataset,
             and extent of the raster dataset.
    :rtype: tuple

    :raises: None
    """
    source_ds = gdal.Open(in_file_name)    
    src_proj = osr.SpatialReference(wkt=source_ds.GetProjection())
    src_ncols = source_ds.RasterXSize
    src_nrows = source_ds.RasterYSize
    xmin,Csize_x,_,ymax,_,Csize_y = source_ds.GetGeoTransform()
    ymin = ymax+src_nrows*Csize_y
    nodata = source_ds.GetRasterBand(1).GetNoDataValue()
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']
    values = [src_ncols,src_nrows,xmin,ymin,Csize_x,nodata]
    Extent = [xmin,xmin+src_ncols*Csize_x,ymin,ymax]
    
    return names,values,src_proj,Extent


def load_float_raster(raster_file):

    """Loads a floating-point raster dataset.

    :param raster_file: Path to the raster file.
    :type raster_file: str

    :return: Tuple containing:
             - Array: 2D NumPy array representing the raster values,
             - Extent: Extent of the raster dataset [xmin, xmax, ymin, ymax],
             - Csize: Cell size of the raster dataset,
             - proj: Projection information of the raster dataset.
    :rtype: tuple

    :raises: None
    """
    dataset = gdal.Open(raster_file,gdal.GA_ReadOnly)
    cols = dataset.RasterXSize
    rows = dataset.RasterYSize    
    geotransform = dataset.GetGeoTransform()
    xmin = geotransform[0]
    xmax = xmin + geotransform[1]*cols
    ymax = geotransform[3]
    ymin = geotransform[3] + geotransform[5]*rows
    Extent = [xmin,xmax,ymin,ymax]
    Csize = abs(geotransform[1])
    proj = dataset.GetProjection()
    dataset_val = dataset.GetRasterBand(1)
    nodatavalue = dataset_val.GetNoDataValue()      
    Array = dataset_val.ReadAsArray()
    if nodatavalue is not None:
        Array[Array==nodatavalue]=-9999
    Array[np.isnan(Array)]=-9999
    dataset.FlushCache()
    
    return np.float_(Array),Extent,Csize,proj


def shapefile_to_np_array(file_name,Extent,Csize,attribute_name,order_field=None,order=None):
    """
    Convert shapefile to numpy array
    ----------
    Parameters
    ----------
    file_name:              string      Complete name of the shapefile to convert
    Extent:                 list        Extent of the array : [xmin,xmax,ymin,ymax]
    Csize:                  int, float  Cell resolution of the output array
    attribute_name:         string      Attribute name of the field used for rasterize
    order_field (optional): string      Attribute name of the field used to order the rasterization
    order (optional):       string      Sorting type : 'ASC' for ascending or 'DESC' descending

    Returns
    -------
    mask_array :            ndarray int32
    ----------
    Examples
    --------
    >>> import ogr,gdal
    >>> import numpy as np
    >>> mask_array = shapefile_to_np_array("Route.shp",[0,1000,0,2000],5,"Importance","Importance",'ASC')
    """
    #Recupere les dimensions du raster ascii
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)
    # Get information from source shapefile
    orig_data_source = ogr.Open(file_name)
    source_ds = ogr.GetDriverByName("Memory").CopyDataSource(orig_data_source, "")
    source_layer = source_ds.GetLayer()
    if order:
        source_layer_ordered = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' ORDER BY '+order_field+' '+order)
    else:source_layer_ordered=source_layer
    source_srs = source_layer.GetSpatialRef()
    # Initialize the new memory raster
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], source_layer_ordered,options=["ATTRIBUTE="+attribute_name,"ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
        
        return mask_arr
  

def prepa_obstacle(Obstacles_directory,Extent,Csize,ncols,nrow):
    
    """Prepares obstacle raster data.

    :param Obstacles_directory: Directory containing obstacle shapefiles.
    :type Obstacles_directory: str
    :param Extent: Extent of the raster dataset [xmin, xmax, ymin, ymax].
    :type Extent: list
    :param Csize: Cell size of the raster dataset.
    :type Csize: float
    :param ncols: Number of columns in the raster dataset.
    :type ncols: int
    :param nrows: Number of rows in the raster dataset.
    :type nrows: int

    :return: Raster representing the location of obstacles (0 where there are no obstacles).
    :rtype: numpy.ndarray

    :raises: None
    """
    liste_file = os.listdir(Obstacles_directory)
    liste_obs = []
    for files in liste_file:
        if files[-4:len(files)]=='.shp':liste_obs.append(Obstacles_directory+files)
    if len(liste_obs)>0:
        Obstacles_skidder = shapefile_obs_to_np_array(liste_obs,Extent,Csize)        
    else: Obstacles_skidder = np.zeros((nrow,ncols),dtype=np.int8)
    
    return Obstacles_skidder


def shapefile_obs_to_np_array(file_list,Extent,Csize):
    """
    Create a numpy array from shapefile contained in a directory
    ----------
    Parameters
    ----------
    file_list:              string      List of .shp file to rasterize
    Extent:                 list        Extent of the area : [xmin,xmax,ymin,ymax]
    Csize:                  int, float  Cell resolution of the area  

    Returns
    -------
    mask_array :            ndarray int32
    """
    #Get raster dimension
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)        
    #Create obstacle raster
    Obstacle = np.zeros((nrows,ncols),dtype=int)
    #Loop on all shaefile
    for shp in file_list:        
        # Get shapefile info
        source_ds = ogr.Open(shp)
        source_layer = source_ds.GetLayer()    
        source_srs = source_layer.GetSpatialRef()
        source_type = source_layer.GetGeomType()
        # Create copy
        target_ds1 = ogr.GetDriverByName("Memory").CreateDataSource("")
        layerName = os.path.splitext(os.path.split(shp)[1])[0]
        layer = target_ds1.CreateLayer(layerName, source_srs, source_type)
        layerDefinition = layer.GetLayerDefn()
        new_field = ogr.FieldDefn('Transfo', ogr.OFTInteger)
        layer.CreateField(new_field)
        ind=0
        for feat in source_layer:
            geometry = feat.GetGeometryRef()
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(geometry)
            feature.SetFID(ind)
            feature.SetField('Transfo',1)
            # Save feature
            layer.CreateFeature(feature)
            # Cleanup
            feature.Destroy()
            ind +=1
        # Initialize raster
        maskvalue = 1    
        xres=float(Csize)
        yres=float(Csize)
        geotransform=(xmin,xres,0,ymax,0, -yres)         
        target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
        target_ds.SetGeoTransform(geotransform)
        if source_srs:
            # Make the target raster have the same projection as the source
            target_ds.SetProjection(source_srs.ExportToWkt())
        else:
            # Source has no projection (needs GDAL >= 1.7.0 to work)
            target_ds.SetProjection('LOCAL_CS["arbitrary"]')
        # Rasterize
        err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=Transfo","ALL_TOUCHED=TRUE"])
        if err != 0:
            raise Exception("error rasterizing layer: %s" % err)
        else:
            target_ds.FlushCache()
            mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
        Obstacle = Obstacle + mask_arr
        target_ds1.Destroy()
        source_ds.Destroy()
    Obstacle = np.int8(Obstacle>0)
    
    return Obstacle


def get_proj_from_road_network(road_network_file):
    
    """Extracts the projection information from a road network file.

    This function opens the provided road network file and retrieves the spatial reference
    information from its layer. It then returns the Well-Known Text (WKT) representation 
    of the spatial reference and the SpatialReference object.

    :param road_network_file: Path to the road network file.
    :type road_network_file: str

    :return: A tuple containing the Well-Known Text (WKT) representation of the spatial reference
             and the SpatialReference object.
    :rtype: tuple

    :raises: None
    """
    source_ds = ogr.Open(road_network_file)
    source_layer = source_ds.GetLayer()    
    source_srs = source_layer.GetSpatialRef()
    
    return source_srs.ExportToWkt(),source_srs

 
def Path_to_lineshape(Path,Line_Shape_Path,projection,Extent,Csize,dtm,nb_lac):
    """
    Convert a file of point coordinate to a line shapefile
    ----------
    Parametres
    ----------
    point_coords:     ndarray float    Matrix contenaing positiosn X Y and line ID
    Line_Shape_Path:  string           Complete name of the output shapefile containing lines
    projection:       string           Spatial projection 

    Examples
    --------
    >>> import ogr,gdal
    >>> points_to_lineshape(point_coords,"Line.shp",projection)
    """
    x0,y0=Extent[0]+0.5*Csize,Extent[3]-0.5*Csize
    #Recupere le driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    # Create output line shapefile 
    if os.path.exists(Line_Shape_Path):driver.DeleteDataSource(Line_Shape_Path)
    target_ds = driver.CreateDataSource(Line_Shape_Path)
    layerName = os.path.splitext(os.path.split(Line_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, projection, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()   
    new_field = ogr.FieldDefn('ID_SEG', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('X_DEB', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Y_DEB', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Z_DEB', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('X_FIN', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Y_FIN', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Z_FIN', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('LPLAN_SEG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('LPLAN_CUM', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L3D_SEG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L3D_CUM', ogr.OFTReal)
    layer.CreateField(new_field)   
    new_field = ogr.FieldDefn('PENTE_LONG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('AZI_DEG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('AZI_GRAD', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('DELTA_Z', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L_PTSUPMAX', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L_PLAT', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('PT_AMONT', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('PT_AVAL', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('P_ROCHER', ogr.OFTInteger)
    layer.CreateField(new_field)
    if nb_lac==0:
        new_field = ogr.FieldDefn('METHOD', ogr.OFTInteger)
        layer.CreateField(new_field)
    nbpts = Path.shape[0]
    ind=0
    point_coords = np.int32(Path[:,0:2])
    prev_L,L3Dcum = 0,0
    while ind<nbpts-1: 
        line = ogr.Geometry(ogr.wkbLineString)
        yS,xS = point_coords[ind]
        yE,xE = point_coords[ind+1]
        yrS,xrS = y0-yS*Csize,xS*Csize+x0
        yrE,xrE = y0-yE*Csize,xE*Csize+x0
        line.AddPoint(xrS,yrS)
        line.AddPoint(xrE,yrE)
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(line)
        feature.SetFID(ind)
        feature.SetField('ID_SEG',ind+1)
        feature.SetField('X_DEB',xrS)
        feature.SetField('Y_DEB',yrS)
        feature.SetField('Z_DEB',dtm[yS,xS])
        feature.SetField('X_FIN',xrE)
        feature.SetField('Y_FIN',yrE)
        feature.SetField('Z_FIN',dtm[yE,xE])
        Lcum = Path[ind+1,4]
        D = Lcum-prev_L       
        feature.SetField('LPLAN_SEG',D)
        feature.SetField('LPLAN_CUM',Lcum)
        prev_L = Lcum
        dZ = dtm[yE,xE]-dtm[yS,xS]
        L3D = np.sqrt(dZ**2+D**2)
        L3Dcum+=L3D
        feature.SetField('L3D_SEG',L3D)
        feature.SetField('L3D_CUM',L3Dcum)
        feature.SetField('PENTE_LONG',Path[ind+1,2])
        feature.SetField('L_PTSUPMAX',Path[ind+1,6])
        feature.SetField('AZI_DEG',Path[ind+1,3])
        feature.SetField('AZI_GRAD',round(Path[ind+1,3]*20/18.,1))
        feature.SetField('DELTA_Z',dZ) 
        if nb_lac==0:
            feature.SetField('METHOD',0) 
        layer.CreateFeature(feature)
        line.Destroy()
        feature.Destroy()
        ind +=1        
    
    target_ds.Destroy() 
    
    
def NewPath_to_lineshape(Path,Line_Shape_Path,projection):
    """
    Convert a file of point coordinate to a line shapefile
    ----------
    Parametres
    ----------
    point_coords:     ndarray float    Matrix contenaing positiosn X Y and line ID
    Line_Shape_Path:  string           Complete name of the output shapefile containing lines
    projection:       string           Spatial projection 

    Examples
    --------
    >>> import ogr,gdal
    >>> points_to_lineshape(point_coords,"Line.shp",projection)
    """   
    #Recupere le driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    # Create output line shapefile 
    if os.path.exists(Line_Shape_Path):driver.DeleteDataSource(Line_Shape_Path)
    target_ds = driver.CreateDataSource(Line_Shape_Path)
    layerName = os.path.splitext(os.path.split(Line_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, projection, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()   
    new_field = ogr.FieldDefn('ID_SEG', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('X_DEB', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Y_DEB', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Z_DEB', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('X_FIN', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Y_FIN', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Z_FIN', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('LPLAN_SEG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('LPLAN_CUM', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L3D_SEG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L3D_CUM', ogr.OFTReal)
    layer.CreateField(new_field)   
    new_field = ogr.FieldDefn('PENTE_LONG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('AZI_DEG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('AZI_GRAD', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('DELTA_Z', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L_PTSUPMAX', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('METHOD', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L_PLAT', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('PT_AMONT', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('PT_AVAL', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('P_ROCHER', ogr.OFTInteger)
    layer.CreateField(new_field)    
    nbpts = Path.shape[0]
    ind=0
    point_coords = Path[:,0:2]
    Lcum,L3Dcum=0,0
    while ind<nbpts-1: 
        line = ogr.Geometry(ogr.wkbLineString)
        yrS,xrS = point_coords[ind]
        yrE,xrE = point_coords[ind+1]
        line.AddPoint(float(xrS),float(yrS))
        line.AddPoint(float(xrE),float(yrE))
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(line)
        feature.SetFID(ind)
        feature.SetField('METHOD',Path[ind+1,8])
        feature.SetField('ID_SEG',ind+1)
        feature.SetField('X_DEB',float(xrS))
        feature.SetField('Y_DEB',float(yrS))
        feature.SetField('Z_DEB',float(Path[ind,9]))
        feature.SetField('X_FIN',float(xrE))
        feature.SetField('Y_FIN',float(yrE))
        feature.SetField('Z_FIN',float(Path[ind+1,9]))
        dZ = Path[ind+1,9]-Path[ind,9]
        L3D = np.sqrt(dZ**2+Path[ind+1,4]**2)
        L3Dcum+=L3D   
        Lcum += Path[ind+1,4]
        feature.SetField('LPLAN_SEG',float(Path[ind+1,4]))
        feature.SetField('LPLAN_CUM',float(Lcum))
        feature.SetField('L3D_SEG',float(L3D))
        feature.SetField('L3D_CUM',float(L3Dcum))
        feature.SetField('PENTE_LONG',float(Path[ind+1,2]))
        feature.SetField('L_PTSUPMAX',float(Path[ind+1,6]))
        feature.SetField('AZI_DEG',float(Path[ind+1,3]))
        feature.SetField('AZI_GRAD',float(round(Path[ind+1,3]*20/18.,1)))
        feature.SetField('DELTA_Z',float(dZ))
        layer.CreateFeature(feature)
        line.Destroy()
        feature.Destroy()
        ind +=1        
    
    target_ds.Destroy()  

   
def reconstruct_path(goal, start, Best,Tab_corresp):    
    
    """Reconstructs the path from the goal node to the start node.

    This function takes the goal node, start node, a matrix containing information
    about the best path, and a matrix containing correspondence between nodes 
    and coordinates, and reconstructs the path from the goal node to the start node.

    :param goal: The goal node representing the end of the path.
    :type goal: int

    :param start: The start node representing the beginning of the path.
    :type start: int

    :param Best: A matrix containing information about the best path.
    :type Best: numpy.ndarray
    :param Tab_corresp: A matrix containing correspondence between nodes and coordinates.
    :type Tab_corresp: numpy.ndarray

    :return: An array representing the reconstructed path, including coordinates,
             azimuth, slope, distance, and additional information.
    :rtype: numpy.ndarray

    :raises: None
    """
    current = goal
    path = []
    while current != start:
        path.append([Tab_corresp[current,0],Tab_corresp[current,1],Best[current,3],
                     Best[current,4],Best[current,2],Best[current,1],Best[current,7]])
        current = int(Best[current,5])
    path.append([Tab_corresp[current,0],Tab_corresp[current,1],-1,-1,0,0,0]) # optional
    path.reverse() # optional
    
    return np.array(path)


def get_Slope(Dtm_file):
    
    """Calculate the slope from a digital terrain model (DTM) raster file.

    This function reads the provided DTM raster file and calculates the slope using GDAL's
    DEMProcessing utility. The slope is computed in percent format.

    :param Dtm_file: The file path to the digital terrain model (DTM) raster file.
    :type Dtm_file: str

    :return: The slope raster array representing the slope of the terrain in percent format.
    :rtype: numpy.ndarray

    :raises: None
    """
    a=gdal.DEMProcessing('slope', Dtm_file, 'slope',slopeFormat="percent",computeEdges=True,format='MEM')
    
    return a.GetRasterBand(1).ReadAsArray()


def get_points_from_waypoints(Waypoints_file,Dtm_file):
    
    """Retrieve points from a waypoints file and convert them to pixel coordinates.

    This function reads a waypoints file containing point features with associated attributes
    and converts the coordinates of each point to pixel coordinates based on the provided
    digital terrain model (DTM) file. The waypoints file should contain fields for 'ID_TRON',
    'ID_POINT', 'BUFF_POINT' to identify each point.

    :param Waypoints_file: Path to the waypoints file.
    :type Waypoints_file: str

    :param Dtm_file: Path to the digital terrain model (DTM) file.
    :type Dtm_file: str

    :raises: None

    :return: Array containing points with pixel coordinates sorted by y-coordinate and then by x-coordinate.
    :rtype: numpy.ndarray
    """
    #Open Dtm_file
    src_ds=gdal.Open(Dtm_file) 
    gt=src_ds.GetGeoTransform()
    
    # Get waypoint
    source_ds = ogr.Open(Waypoints_file)
    source_layer = source_ds.GetLayer()
    geoLocations = []    
    for feat in source_layer:
        geom = feat.GetGeometryRef() 
        idtron = feat.GetField("ID_TRON")
        idpt = feat.GetField("ID_POINT")
        buff = feat.GetField("BUFF_POINT") 
        seg = []  
        mx,my,_ = geom.GetPoint(0)
        #Convert from map to pixel coordinates.
        #Only works for geotransforms with no rotation.
        px = int((mx - gt[0]) / gt[1]) #x pixel
        py = int((my - gt[3]) / gt[5]) #y pixel       
        seg.append(idtron)
        seg.append(idpt)
        seg.append(buff)
        seg.append(py)
        seg.append(px)        
        geoLocations.append(seg)
    
    pt_list = np.int16(geoLocations)
    ind = np.lexsort((pt_list[:,1], pt_list[:,0]))   
     
    return pt_list[ind]
    

def get_waypoints(id_tron,pt_list): 
    
    """Retrieve waypoints corresponding to a specific road segment.

    This function takes a road segment ID and a list of points, and returns a list of
    waypoints representing the segment. Waypoints are defined by their starting and ending
    coordinates and the associated buffer size.

    :param id_tron: ID of the road segment.
    :type id_tron: int

    :param pt_list: Array containing points with attributes.
    :type pt_list: numpy.ndarray

    :raises: None

    :return: List of waypoints defining the road segment, each containing the starting and
             ending coordinates and the associated buffer size.
    :rtype: list
    """
    seg_list = []
    ptlist2 = pt_list[pt_list[:,0]==id_tron]
    nbpt = ptlist2.shape[0]
             
    for i in range(nbpt-1):
        start = ptlist2[i,3],ptlist2[i,4]   
        end = ptlist2[i+1,3],ptlist2[i+1,4]   
        seg_list.append([start,end,ptlist2[i+1,2]])
    return seg_list


def ArrayToGtiff(Array,file_name,Extent,nrows,ncols,road_network_proj,nodata_value,raster_type='INT32'):
    """
    Create Tiff raster from numpy array   
    ----------
    Parameters
    ----------
    Array:             np.array    Array name
    file_name:         string      Complete name of the output raster
    Extent:            list        Extent of the area : [xmin,xmax,ymin,ymax]
    nrows:             int         Number of rows in the array
    ncols:             int         Number of columns in the array
    Csize:             int, float  Cell resolution of the array  
    road_network_proj: string      Spatial projection
    nodata_value:      int, float  Value representing nodata in the array
    raster_type:       string      'INT32' (default),'UINT8','UINT16','FLOAT32','FLOAT16'

    """
    xmin,xmax,ymin,ymax=Extent[0],Extent[1],Extent[2],Extent[3]
    xres=(xmax-xmin)/float(ncols)
    yres=(ymax-ymin)/float(nrows)
    geotransform=(xmin,xres,0,ymax,0, -yres)
    if raster_type=='INT32':
        #-2147483648 to 2147483647
        DataType = gdal.GDT_Int32    
    elif raster_type=='UINT8':
        #0 to 255
        DataType = gdal.GDT_Byte
    elif raster_type=='UINT16':
        #0 to 65535    
        DataType = gdal.GDT_UInt16
    elif raster_type=='INT16':
        #-32768 to 32767 
        DataType = gdal.GDT_Int16
    elif raster_type=='FLOAT32':
        #Single precision float: sign bit, 8 bits exponent, 23 bits mantissa
        DataType = gdal.GDT_Float32
    elif raster_type=='FLOAT16':
        #Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
        DataType = gdal.GDT_Float16
    target_ds = gdal.GetDriverByName('GTiff').Create(file_name+'.tif', int(ncols), int(nrows), 1, DataType)
    target_ds.SetGeoTransform(geotransform)
    target_ds.SetProjection(road_network_proj)
    target_ds.GetRasterBand(1).WriteArray( Array )
    target_ds.GetRasterBand(1).SetNoDataValue(nodata_value)
    target_ds.GetRasterBand(1).GetStatistics(0,1)
    target_ds.FlushCache()
    
