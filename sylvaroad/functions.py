"""
/***************************************************************************
 functions
                                 A QGIS plugin
 This is an adaption of the SylvaRoad app for in qgis uses
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-03-05
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Cosylval
        email                : yoann.zenner@viacesi.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QCoreApplication
import os
from .GIS import raster_get_info,check_field,ArrayToGtiff,shapefile_to_np_array,load_float_raster,get_points_from_waypoints,Astar_buf_wp,get_Slope
from .GIS import get_waypoints,prepa_obstacle,Path_to_lineshape,NewPath_to_lineshape,test_point_within,get_id_lacets,trace_lace,get_proj_from_road_network
from .console import printor
from .functions_np import build_NeibTable,calcul_distance_de_cout,calc_local_slope,save_param_file
import numpy as np
      

def road_finder_exec_force_wp1(Dtm_file,Obs_Dir,Waypoints_file,Property_file,Result_Dir,                              
                              trans_slope_all,trans_slope_hairpin,min_slope,max_slope,
                              penalty_xy,penalty_z,D_neighborhood,max_diff_z,angle_hairpin,
                              Lmax_ab_sl,Wspace,Radius):
    printor(1)

    #Test if spatial data are OK
    test,mess,Csize = check_files(Dtm_file,Waypoints_file,Property_file)
    
    #Save parameters into npy file
    param = get_param(trans_slope_all,trans_slope_hairpin,
              min_slope,max_slope,
              penalty_xy,penalty_z,
              D_neighborhood,max_diff_z,angle_hairpin,
              Dtm_file,Obs_Dir,Waypoints_file,Property_file,Csize,Lmax_ab_sl,Radius)
    
    Rspace =create_res_dir(Result_Dir,
                           trans_slope_all,trans_slope_hairpin,
                           min_slope,max_slope,
                           penalty_xy,penalty_z,
                           D_neighborhood)
    
    save_param_file(Wspace,Dtm_file,Obs_Dir,Waypoints_file,Property_file,
                    Result_Dir,trans_slope_all,trans_slope_hairpin,
                    min_slope,max_slope,penalty_xy,penalty_z,
                    D_neighborhood,max_diff_z,angle_hairpin,Lmax_ab_sl,
                    Rspace,Radius)
    res_process = road_finder_exec_force_wp2(Dtm_file,Obs_Dir,Waypoints_file,Property_file,
                              trans_slope_all,trans_slope_hairpin,min_slope,max_slope,
                              penalty_xy,penalty_z,D_neighborhood,max_diff_z,angle_hairpin,
                              Lmax_ab_sl,Radius,test,mess,Csize,Rspace)
    
    return Rspace,param,res_process
    

def road_finder_exec_force_wp2(Dtm_file,Obs_Dir,Waypoints_file,Property_file,
                              trans_slope_all,trans_slope_hairpin,min_slope,max_slope,
                              penalty_xy,penalty_z,D_neighborhood,max_diff_z,angle_hairpin,
                              Lmax_ab_sl,Radius,test,mess,Csize,Rspace):
    

    if not test:
        printor(2,mess)
        
    else:    
        printor(3)
        #load data   
        dtm,Extent,Csize,proj = load_float_raster(Dtm_file)
        nrows,ncols=dtm.shape
        if Obs_Dir!='':
            Obs = prepa_obstacle(Obs_Dir,Extent,Csize,ncols,nrows)
        else:
            Obs = np.zeros_like(dtm,dtype=np.int8)
        
        pt_list=get_points_from_waypoints(Waypoints_file,Dtm_file)  
        tron_list = np.unique(pt_list[:,0])
        
        if Property_file!="":
            Fonc = shapefile_to_np_array(Property_file,Extent,Csize,"FONC_OK",
                                     order_field=None,order=None)
        else:
            Fonc = np.ones_like(dtm,dtype=np.int8)
        
        #get usefull variables
        printor(4)

           
        road_network_proj,proj = get_proj_from_road_network(Waypoints_file)  
        Obs[dtm==-9999]=1
        Obs[Fonc==0]=2
        del Fonc
        
        
        #Compute Slope raster and Local Slope raster
        Perc_Slope = get_Slope(Dtm_file)
        Perc_Slope[dtm==-9999]=-9999
        Local_Slope =  calc_local_slope(Perc_Slope,1.25*Radius,Csize,trans_slope_hairpin)                            
          
        #Build neigborhood table
        IdVois, Id, Tab_corresp,IdPix,Slope,Dist,Az = build_NeibTable(D_neighborhood,Csize,dtm,np.int8(Obs>0),min_slope,max_slope)
        
        res_process = QCoreApplication.translate("MainWindow",'\n\nRésultat par tronçon')
        
        Generaltest=0
        road_finder_exec_force_wp3(trans_slope_all,min_slope,max_slope,
                                    penalty_xy,penalty_z,D_neighborhood,max_diff_z,angle_hairpin,
                                    Lmax_ab_sl,Radius,test,Csize,Rspace,tron_list,
                                    road_network_proj,proj,Extent,dtm,Obs,IdVois, Id, Tab_corresp,
                                    IdPix,Az,Dist,Local_Slope,res_process,Generaltest,pt_list,Slope,Perc_Slope,
                                    nrows,ncols)
        return res_process


def road_finder_exec_force_wp3(trans_slope_all,min_slope,max_slope,
                                  penalty_xy,penalty_z,D_neighborhood,max_diff_z,angle_hairpin,
                                  Lmax_ab_sl,Radius,test,Csize,Rspace,tron_list,
                                  road_network_proj,proj,Extent,dtm,Obs,IdVois, Id, Tab_corresp,
                                  IdPix,Az,Dist,Local_Slope,res_process,Generaltest,pt_list,Slope,Perc_Slope,
                                  nrows,ncols):
    
    for id_tron in tron_list:  
        printor(9,id_tron)
        segments = get_waypoints(id_tron,pt_list)           
        #Check if points are within MNT/property and are not ostacles
        test, res_process,end = test_point_within(segments,dtm,Obs,id_tron,res_process)
        if not test : continue
            
        #Check if points are within possible prospection
        Dist_to_End =  calcul_distance_de_cout(end[0],end[1],np.int8(Obs==0),Csize,Max_distance=100000)    
        test=1
        for i in range(0,len(segments)):
            start = segments[i][0]
            if Dist_to_End[start]<0:                    
                if i==0:
                    txt = QCoreApplication.translate("MainWindow",'   Tronçon n°')+str(int(id_tron))+QCoreApplication.translate("MainWindow",' : Des obstacles empêchent de joindre le début et la fin du tronçon')
                else:
                    txt = QCoreApplication.translate("MainWindow",'   Tronçon n°')+str(int(id_tron))+QCoreApplication.translate("MainWindow"," : Des obstacles empêchent d'atteindre le point de passage ID_POINT ")+str(i+1)
                printor(2,txt)
                res_process+= txt+'\n'
                test=0
        
        if not test:continue
        
        #Process
        newObs = np.copy(np.int8(Obs>0))
        newObs[Dist_to_End<0]=1
        txt = ""
        
        Path,test = Astar_buf_wp(segments,Slope,IdVois, Id, Tab_corresp,IdPix,Az,Dist,
                                min_slope,max_slope,penalty_xy,penalty_z,Dist_to_End,
                                Local_Slope,Perc_Slope,Csize,dtm,max_diff_z,
                                trans_slope_all,newObs,angle_hairpin,Lmax_ab_sl,Radius,
                                D_neighborhood)
        
        Lsl=np.sum(Path[:,6]) 
        nb_lac = len(get_id_lacets(Path,angle_hairpin))  
        if test==1:                             
            Path_to_lineshape(Path,Rspace+'Troncon_'+str(int(id_tron))+'_complet.shp',proj,Extent,Csize,dtm,nb_lac)   
            if nb_lac>0:
                NewPath = trace_lace(Path, Radius,Extent,Csize,angle_hairpin,dtm,coefplat=2)
                NewPath_to_lineshape(NewPath,Rspace+'Troncon_'+str(int(id_tron))+'_lacets_corriges.shp',proj)                     
                if  Generaltest==0:
                    ArrayToGtiff(Local_Slope,Rspace+"PenteLocale_Lacet",Extent,nrows,ncols,road_network_proj,255,raster_type='UINT8') 
                    Generaltest=1
                #Path_to_lace(Path,Rspace+'Lacets_Troncon_'+str(int(id_tron))+'.shp',proj,Extent,Csize,dtm)
            txt = QCoreApplication.translate("MainWindow",'\n    Tronçon n°')+str(int(id_tron))+QCoreApplication.translate("MainWindow",' : Un chemin optimal a été trouvé. ')
            txt +=QCoreApplication.translate("MainWindow",'\n                  Longueur planimétrique : ')+str(int((Path[-1,4])+0.5))+" m"
            if nb_lac>0:
                txt +=QCoreApplication.translate("MainWindow",'\n                  Longueur planimétrique (avec lacets corrigés) : ')
                txt +=str(int(np.sum(NewPath[:,4])+0.5))+" m"
            txt +=QCoreApplication.translate("MainWindow",'\n                  Nombre de lacets : ')+str(int(nb_lac))
            if Lsl>0:
                txt += "\n                  "+ QCoreApplication.translate("MainWindow","Sur ")+str(int(Lsl+0.5))+QCoreApplication.translate("MainWindow"," m, la pente en travers est supérieure à la pente en travers max.")
            printor(2,txt) 
            
        else: 
            Path_to_lineshape(Path,Rspace+'Troncon_'+str(int(id_tron))+'_incomplet.shp',proj,Extent,Csize,dtm,nb_lac)
            txt += QCoreApplication.translate("MainWindow",'\n    Tronçon n°')+str(int(id_tron))+QCoreApplication.translate("MainWindow",' : Aucun chemin trouvé. ')
            txt += QCoreApplication.translate("MainWindow",'\n                  Le chemin le plus proche du but a été sauvegardé. ')               
            printor(2,txt) 
        res_process+= txt+"\n"


def get_param(trans_slope_all,trans_slope_hairpin,min_slope,max_slope,penalty_xy,
              penalty_z,D_neighborhood,max_diff_z,angle_hairpin,Dtm_file,Obs_Dir,
              Waypoints_file,Property_file,Csize,Lmax_ab_sl,Radius):
    
    
    """Generate a text summary of the parameters used for modeling.

    This function constructs a text summary containing the filenames of the files
    used for modeling (MNT, Points de passage, Foncier, and Dossier Obstacles) and
    the parameters used for the modeling process.

    :param trans_slope_all: Maximum slope in traverse direction at any point.
    :type trans_slope_all: float

    :param trans_slope_hairpin: Maximum slope in traverse direction for placing a hairpin turn.
    :type trans_slope_hairpin: float

    :param min_slope: Minimum slope in longitudinal direction.
    :type min_slope: float

    :param max_slope: Maximum slope in longitudinal direction.
    :type max_slope: float

    :param penalty_xy: Penalty for changing direction.
    :type penalty_xy: float

    :param penalty_z: Penalty for changing the slope direction.
    :type penalty_z: float

    :param D_neighborhood: Radius of search around a pixel.
    :type D_neighborhood: float

    :param max_diff_z: Maximum difference between terrain altitude and theoretical altitude of the trace.
    :type max_diff_z: float

    :param angle_hairpin: Angle beyond which a turn is considered a hairpin.
    :type angle_hairpin: float

    :param Dtm_file: Path to the Digital Terrain Model (MNT) file.
    :type Dtm_file: str

    :param Obs_Dir: Directory containing obstacle files.
    :type Obs_Dir: str

    :param Waypoints_file: Path to the waypoints file.
    :type Waypoints_file: str

    :param Property_file: Path to the property file.
    :type Property_file: str

    :param Csize: Resolution of the MNT file (cell size).
    :type Csize: float

    :param Lmax_ab_sl: Maximum cumulative length with cross slope > maximum cross slope.
    :type Lmax_ab_sl: float

    :param Radius: Turning radius applied to hairpin turns.
    :type Radius: float

    :return: Text summary of the parameters used for modeling.
    :rtype: str
    """
    txt = QCoreApplication.translate("MainWindow","FICHIERS UTILISES POUR LA MODELISATION:") + "\n\n"
    txt += QCoreApplication.translate("MainWindow","   - MNT :                   ") + Dtm_file+"\n"
    txt += QCoreApplication.translate("MainWindow","     Résolution (m) :        ")+str(Csize)+" m\n"
    txt += QCoreApplication.translate("MainWindow","   - Points de passage :     ") + Waypoints_file+"\n"
    txt += QCoreApplication.translate("MainWindow","   - Foncier :               ") + Property_file+"\n"
    txt += QCoreApplication.translate("MainWindow","   - Dossier Obstacles :     ") + Obs_Dir+"\n\n\n"
    txt += "" .join (["_"]*80) + "\n\n"
    txt += QCoreApplication.translate("MainWindow", "PARAMETRES UTILISES POUR LA MODELISATION:")+ "\n\n"
    txt += QCoreApplication.translate("MainWindow","   - Pente en long min. :")+"                                                        "+str(min_slope)+" %\n"
    txt += QCoreApplication.translate("MainWindow","   - Pente en long max. :")+"                                                        "+str(max_slope)+" %\n"
    txt += QCoreApplication.translate("MainWindow","   - Pente en travers max. en tout point :")+"                                       "+str(trans_slope_all)+" %\n"
    txt += QCoreApplication.translate("MainWindow","   - Pente en travers max. pour implanter un virage en lacet :")+"                   "+str(trans_slope_hairpin)+"  %\n"
    txt += QCoreApplication.translate("MainWindow","   - Pénalité de changement de direction :")+"                                       "+str(penalty_xy)+" m/"+str(angle_hairpin)+"°\n"
    txt += QCoreApplication.translate("MainWindow","   - Pénalité de changement du sens de pente en long :")+"                           "+str(penalty_z)+" m\n"
    txt += QCoreApplication.translate("MainWindow","   - Rayon de recherche autour d'un pixel :")+"                                      "+str(D_neighborhood)+" m\n"
    txt += QCoreApplication.translate("MainWindow","   - Différence max. entre altitude du terrain et altitude théorique du trace :")+"  "+str(max_diff_z)+" m\n"
    txt += QCoreApplication.translate("MainWindow","   - Angle au-delà duquel un virage est considéré comme lacet :")+"                  "+str(angle_hairpin)+" °\n"
    txt += QCoreApplication.translate("MainWindow","   - Rayon de braquage appliqué aux lacets :")+"                                     "+str(Radius)+" m\n"
    txt += QCoreApplication.translate("MainWindow","   - Longueur cumulée max. avec Pente en travers > Pente en travers max. :")+"       "+str(Lmax_ab_sl)+" m\n"
    
    return txt


def create_res_dir(Result_Dir,trans_slope_all,trans_slope_hairpin,min_slope,max_slope,penalty_xy,penalty_z,D_neighborhood):
    
    
    """Create a directory for storing simulation results based on specified parameters.

    This function creates a directory within the specified Result_Dir to store simulation results.
    The directory name is generated based on the provided parameters, including:

    - trans_slope_all: Transition slope for all road sections.
    - trans_slope_hairpin: Transition slope specifically for hairpin turns.
    - min_slope: Minimum allowable slope for road segments.
    - max_slope: Maximum allowable slope for road segments.
    - penalty_xy: Penalty factor for changes in x-y direction.
    - penalty_z: Penalty factor for changes in z (elevation) direction.
    - D_neighborhood: Neighborhood distance for considering adjacent pixels in computations.

    The directory name format is as follows:
    Simu_<optnum>_Pl(<min_slope>-<max_slope>)_Pt(<trans_slope_all>-<trans_slope_hairpin>)_Pen(<penalty_xy>-<penalty_z>)_D(<D_neighborhood>)

    :param Result_Dir: The path to the directory where simulation results will be stored.
    :type Result_Dir: str

    :param trans_slope_all: Transition slope for all road sections.
    :type trans_slope_all: float

    :param trans_slope_hairpin: Transition slope specifically for hairpin turns.
    :type trans_slope_hairpin: float

    :param min_slope: Minimum allowable slope for road segments.
    :type min_slope: float

    :param max_slope: Maximum allowable slope for road segments.
    :type max_slope: float

    :param penalty_xy: Penalty factor for changes in x-y direction.
    :type penalty_xy: float

    :param penalty_z: Penalty factor for changes in z (elevation) direction.
    :type penalty_z: float

    :param D_neighborhood: Neighborhood distance for considering adjacent pixels in computations.
    :type D_neighborhood: float


    :return: The path to the created directory for storing simulation results.
    :rtype: str

    :raises: None
    """
    dirs = [d for d in os.listdir(Result_Dir) if os.path.isdir(os.path.join(Result_Dir, d))]
    list_dir = []
    for dire in dirs:
        if dire[:5]=='Simu_':
            list_dir.append(dire)
    optnum = len(list_dir)+1
    Rspace=Result_Dir+'Simu_'+str(optnum)    
    Rspace+="_Pl("+str(min_slope)+"-"+str(max_slope)+")"
    Rspace+="_Pt("+str(trans_slope_all)+"-"+str(trans_slope_hairpin)+")"
    Rspace+="_Pen("+str(penalty_xy)+"-"+str(penalty_z)+")"
    Rspace+="_D("+str(D_neighborhood)+")"
    try:os.mkdir(Rspace)
    except:pass   
    
    return Rspace+'/'

#Chech all spatial entries before processing
def check_files(Dtm_file,Waypoints_file,Property_file):
    
    """Checks the validity of input spatial files.

    :param Dtm_file: Path to the Digital Terrain Model (DTM) raster file.
    :type Dtm_file: str

    :param Waypoints_file: Path to the waypoints spatial file.
    :type Waypoints_file: str
    
    :param Property_file: Path to the property spatial file.
    :type Property_file: str

    :return: Tuple containing:
             - Status of file checks (1 if all checks pass, 0 otherwise),
             - Message detailing any identified problems with the input files,
             - Cell size of the DTM raster file.
    :rtype: tuple

    :raises: None
    """
    test = 1
    Csize = None
    mess=QCoreApplication.translate("MainWindow","\nLES PROBLEMES SUIVANTS ONT ETE IDENTIFIES CONCERNANT LES ENTREES SPATIALES: \n")
    #Check DTM    
    try:
        _,values,_,_ = raster_get_info(Dtm_file)  
        Csize = values[4]
        if values[5]==None:           
            mess+=QCoreApplication.translate("MainWindow"," -   Raster MNT : Aucune valeur de NoData definie. Attention, cela peut engendrer des résultats éronnés.\n" )
    except:
        test=0
        mess+=QCoreApplication.translate("MainWindow"," -   Raster MNT :  Le chemin d'acces est manquant ou incorrect. Ce raster est obligatoire\n") 
            
    #Check Waypoints 
    try:    
        testfd = check_field(Waypoints_file,"ID_TRON")
        if testfd==0:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -  Couche points de passage : Le champs 'ID_TRON' est manquant\n"  )
        elif testfd==2:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -  Couche points de passage : Veuillez remplir le champs 'ID_TRON' pour toutes les entités\n")         
        
        testfd =  check_field(Waypoints_file,"ID_POINT")
        if testfd==0:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -  Couche points de passage : Le champs 'ID_POINT' est manquant\n"  )
        elif testfd==2:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -  Couche points de passage : Veuillez remplir le champs 'ID_POINT' pour toutes les entités\n" )       
        
        testfd = check_field(Waypoints_file,"BUFF_POINT")
        if testfd==0:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -  Couche points de passage : Le champs 'BUFF_POINT' est manquant\n" ) 
        elif testfd==2:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -  Couche points de passage : Veuillez remplir le champs 'BUFF_POINT' pour toutes les entités\n"   )         
    except:
        test=0
        mess+=QCoreApplication.translate("MainWindow"," -   Couche points de passage : Le chemin d'acces est manquant ou incorrect. Cette couche est obligatoire\n" )
    
    #Check foncier    
    if Property_file!="":   
        try:
            testfd = check_field(Property_file,"FONC_OK")
            if testfd==0:
                test=0
                mess+=QCoreApplication.translate("MainWindow"," -  Couche foncier : Le champs 'FONC_OK' est manquant\n"  )
            elif testfd==2:
                test=0
                mess+=QCoreApplication.translate("MainWindow"," -  Couche foncier : Veuillez remplir le champs 'FONC_OK' pour toutes les entités\n"    ) 
        except:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -   Couche foncier : Le chemin d'acces est incorrect. \n")
    if not test:
        mess+="\n"
        mess+=QCoreApplication.translate("MainWindow","MERCI DE CORRIGER AVANT DE RELANCER L'OUTIL\n")
    
    return test,mess,Csize

