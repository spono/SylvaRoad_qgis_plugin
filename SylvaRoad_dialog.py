# -*- coding: utf-8 -*-
"""
/***************************************************************************
 sylvaroadDialog
                                 A QGIS plugin
 This is an adaption of the SylvaRoad app for in qgis uses
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-03-05
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Cosylval
        email                : yoann.zenner@viacesi.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""


from qgis.PyQt import uic, QtWidgets
from PyQt5.QtWidgets import QFileDialog
from PyQt5.QtCore import QCoreApplication
import os,datetime
from .console import printor
from .functions import road_finder_exec_force_wp

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'SylvaRoad_dialog_base.ui'))


class sylvaroadDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self,iface = None, parent=None):
        """Constructor."""
        super(sylvaroadDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.setWindowTitle("SylvaRoad")
#self.setWindowIcon(QIcon(':/plugins/sylvaccess_plugin/icon.png'))
        self.iface = iface
        global Sylvaroad_UI
        Sylvaroad_UI = self


##################################################################
#.______     ______    __    __  .__________.  ______   .__   __.# 
#|   _  \   /  __  \  |  |  |  | |          | /  __  \  |  \ |  |# 
#|  |_)  | |  |  |  | |  |  |  | `---|  |---`|  |  |  | |   \|  |# 
#|   _  <  |  |  |  | |  |  |  |     |  |    |  |  |  | |  . `  |# 
#|  |_)  | |  `--'  | |  `--'  |     |  |    |  `--'  | |  |\   |# 
#|______/   \______/   \______/      |__|     \______/  |__| \__|# 
################################################################## 
        for i in range(1, 7):
            button = getattr(self, f"pushButton_{i}")
            button.clicked.connect(lambda _, num=i: self.open_folder(num))

        self.button_box.accepted.connect(self.launch)
        self.button_box.rejected.connect(self.abort)
        

    def open_folder(self, button_number):
        # Définit les filtres génériques pour Shapefiles et fichiers raster
        shapefile_filter = "Shapefiles (*.shp );;Geopackage(*.gpkg);;All files (*)"
        raster_filter = "Raster files (*.tif *.asc *.txt);;All files (*)"

        # Définit les options de la boîte de dialogue
        options = QFileDialog.Options()
        #options |= QFileDialog.DontUseNativeDialog

        # Affiche le dialogue de sélection de fichier avec les filtres appropriés
        if button_number == 4:
            selected_file, _ = QFileDialog.getOpenFileName(None, QCoreApplication.translate("MainWindow","Select a file"), filter=shapefile_filter, options=options)
        elif button_number == 2:
            selected_file, _ = QFileDialog.getOpenFileName(None, QCoreApplication.translate("MainWindow","Select a file"), filter=raster_filter, options=options)
        elif button_number in [1, 3, 5, 6]: 
            selected_file = QFileDialog.getExistingDirectory(None, QCoreApplication.translate("MainWindow","Select a folder"), options=options)

        if selected_file:
            text_edit = getattr(self, f"lineEdit_{button_number}")
            text_edit.setText(selected_file)


#####################################################################################################################
#  _______  _______ .___________.   ____    ____  ___      .______    __       ___      .______    __       _______ #
# /  _____||   ____||           |   \   \  /   / /   \     |   _  \  |  |     /   \     |   _  \  |  |     |   ____|#
#|  |  __  |  |__   `---|  |----`    \   \/   / /  ^  \    |  |_)  | |  |    /  ^  \    |  |_)  | |  |     |  |__   #
#|  | |_ | |   __|      |  |          \      / /  /_\  \   |      /  |  |   /  /_\  \   |   _  <  |  |     |   __|  #
#|  |__| | |  |____     |  |           \    / /  _____  \  |  |\  \-.|  |  /  _____  \  |  |_)  | |  `----.|  |____ #
# \______| |_______|    |__|            \__/ /__/     \__\ | _| `.__||__| /__/     \__\ |______/  |_______||_______|#
#####################################################################################################################
            
            
    def get_variables(self):
        Workspace = self.lineEdit_1.text()
        Workspace += "/"
        Dtm_file = self.lineEdit_2.text()
        Obs_Dir = self.lineEdit_3.text()
        if Obs_Dir:
            Obs_Dir += "/"
        Waypoints_file = self.lineEdit_4.text()
        Property_file = self.lineEdit_5.text()
        if Property_file:
            Property_file += "/"
        Result_Dir = self.lineEdit_6.text()
        Result_Dir += "/"
        trans_slope_all = self.spinBox_1.value()       # [%] Max cross slope outside hairpin
        trans_slope_hairpin = self.spinBox_1.value()   # [%] Max cross slope at hairpin
        min_slope = self.spinBox_1.value()             # [%] Min slope of the road
        max_slope = self.spinBox_2.value()             # [%] Max slope of the road
        penalty_xy = self.spinBox_3.value()            # [m/180°] Turn around penalty
        penalty_z = self.spinBox_4.value()             # [m/2*max(min_slope,max_slope)] "Wave" penalty
        D_neighborhood = self.spinBox_5.value()        # [m] Distance of the viciny around pixel
        max_diff_z = self.spinBox_6.value()            # [m] Max difference of elevation between terrain and
                                                       #     theoretical elevation of the road 
        angle_hairpin = self.spinBox_7.value()         # [°] Min angle for a turn to be considered as hairpin
        Lmax_ab_sl = self.spinBox_8.value()            # [m] Max length of road with cross slope > trans_slope_all
        Radius = self.spinBox_9.value()                # [m] Radius for trucks
        return Workspace,Dtm_file,Obs_Dir,Waypoints_file,Property_file,Result_Dir,trans_slope_all,trans_slope_hairpin,min_slope,max_slope,penalty_xy,penalty_z,D_neighborhood,max_diff_z,angle_hairpin,Lmax_ab_sl,Radius


################################################################################
### Script execution
################################################################################
        

    def launch(self):
        Hdebut = datetime.datetime.now()
        printor(10)
        ##test
        self.lineEdit_1.setText("C:/Users/yoann/Downloads/meisenthal2")
        self.lineEdit_2.setText("C:/Users/yoann/Downloads/meisenthal2/mnt_rgealti_5m.tif")
        self.lineEdit_3.setText("C:/Users/yoann/Downloads/meisenthal2/empty")
        self.lineEdit_4.setText("C:/Users/yoann/Downloads/meisenthal2/test7.shp")
        self.lineEdit_6.setText("C:/Users/yoann/Downloads/meisenthal2/results2")
        ##
        Wspace,Dtm_file,Obs_Dir,Waypoints_file,Property_file,Result_Dir,trans_slope_all,trans_slope_hairpin,min_slope,max_slope,penalty_xy,penalty_z,D_neighborhood,max_diff_z,angle_hairpin,Lmax_ab_sl,Radius = self.get_variables()
        
        if 'Wspace' not in locals() or 'Wspace' not in globals() :
            Wspace = Result_Dir

        try :
            Rspace,param,res_process = road_finder_exec_force_wp(Dtm_file,Obs_Dir,Waypoints_file,Property_file,Result_Dir,
                                                                    trans_slope_all,trans_slope_hairpin,min_slope,max_slope,
                                                                    penalty_xy,penalty_z,D_neighborhood,max_diff_z,
                                                                    angle_hairpin,Lmax_ab_sl,Wspace,Radius)
        except Exception as e:
            printor(12,"Rspace: ",Rspace)
            printor(12,"param: ",param)
            printor(12,"res_process: ",res_process)
            printor(2, e)
            Sylvaroad_UI.abort()
        str_duree,str_fin,str_debut=heures(Hdebut) 
        try:
            create_param_file(Rspace,param,res_process,str_duree,str_fin,str_debut)
        except:pass
        printor(5)
        printor(11)
        Sylvaroad_UI.abort()


    def abort(self):
        self.close()
        return
    

###############################################################################
### Functions
###############################################################################

def heures(Hdebut):
    
    """Calculate the duration between a given start time and the current time.

    This function takes a start time (Hdebut) as input and calculates the duration
    between that start time and the current time (Hfin). It then formats this duration
    along with the start and end times into strings.

    :param Hdebut: The start time.
    :type Hdebut: datetime.datetime

    :return: A tuple containing:
             - The formatted duration string (e.g., '3h 15m 20s').
             - The formatted current time string.
             - The formatted start time string.
    :rtype: tuple

    :raises: None
    """
    Hfin = datetime.datetime.now()
    duree = Hfin - Hdebut
    str_duree = str(duree).split('.')[0]
    str_duree = str_duree.split(':')[0] + 'h ' + str_duree.split(':')[1] + 'm ' + str_duree.split(':')[2] + 's'
    str_debut = Hdebut.strftime('%d/%m/%Y %H:%M:%S')
    str_fin = Hfin.strftime('%d/%m/%Y %H:%M:%S')
    
    return str_duree, str_fin, str_debut


def create_param_file(Rspace,param,res_process,str_duree,str_fin,str_debut):
    
    """Create a parameter file summarizing simulation results and processing details.

    This function generates a text file containing details about the simulation parameters,
    processing results, and execution duration.

    :param Rspace: Directory where the parameter file will be saved.
    :type Rspace: str

    :param param: Text summary of the parameters used for modeling.
    :type param: str

    :param res_process: Text summary of the processing results.
    :type res_process: str

    :param str_duree: Duration of script execution.
    :type str_duree: str

    :param str_fin: Date and time at the end of script execution.
    :type str_fin: str

    :param str_debut: Date and time at the start of script execution.
    :type str_debut: str

    :raises: None

    :rtype: None
    """
    filename = Rspace +"Parametre_simulation.txt"    
    txt = QCoreApplication.translate("MainWindow","SylvaRoaD")+"\n\n"
    ver =  "0.2"
    date = "03/2024"
    txt += QCoreApplication.translate("MainWindow","Version du programme:" + ver + date)+"\n"
    txt += QCoreApplication.translate("MainWindow","Auteur: Zenner Yoann - Cosylval")+"\n\n"
    txt += QCoreApplication.translate("MainWindow","Date et heure de lancement du script:")+"                                      "+str_debut+"\n"
    txt += QCoreApplication.translate("MainWindow","Date et heure a la fin de l'éxécution du script:")+"                           "+str_fin+"\n"
    txt += QCoreApplication.translate("MainWindow","Temps total d'éxécution du script:")+"                                         "+str_duree+"\n\n"
    txt += "" .join (["_"]*80) + "\n\n"
    txt += param
    txt += "" .join (["_"]*80) + "\n\n"
    txt += res_process    
    fichier = open(filename, "w")
    fichier.write(txt)
    fichier.close()
    