"""
/***************************************************************************
 functions_np
                                 A QGIS plugin
 This is an adaption of the SylvaRoad app for in qgis uses
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-03-05
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Cosylval
        email                : yoann.zenner@viacesi.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import numpy as np



#############################################################


#CYTHON
        

#############################################################


def calculate_azimut(x1, y1, x2, y2):
    DX = x2 - x1
    DY = y2 - y1
    Angle = np.arctan2(DY, DX) * 180/ np.pi
    Angle = (Angle + 360) % 360
    return Angle


def conv_az_to_polar(az):
    val = (450 - az) % 360
    return val


def diff_az(az_to, az_from):
    diff_clockwise = (az_to - az_from) % 360
    diff_counterclockwise = (az_from - az_to) % 360
    return min(diff_clockwise, diff_counterclockwise)


def check_focal_nb(raster, rayon, Csize, x1, y1, nline, ncol, trans_slope_hairpin):
    cote = int(rayon / Csize)
    nbsup,nb = 0,0
    for y in range(max(0, y1 - cote), min(nline, y1 + cote + 1)):
        for x in range(max(0, x1 - cote), min(ncol, x1 + cote + 1)):
            if np.sqrt((x1 - x) ** 2 + (y1 - y) ** 2) * Csize > rayon:
                continue
            if raster[y, x] != -9999:
                nb += 1
            if raster[y, x] > trans_slope_hairpin:
                nbsup += 1
    
    return 1. * nbsup / nb


def calc_local_slope(raster, rayon, Csize, trans_slope_hairpin):
    nline, ncol = raster.shape
    local_slope = np.ones((nline, ncol), dtype=np.uint8) * 255
    for y in range(nline):
        for x in range(ncol):
            if raster[y, x] != -9999:
                local_slope[y, x] = int(100 * check_focal_nb(raster, rayon, Csize, x, y, nline, ncol, trans_slope_hairpin) + 0.5)
    
    return local_slope


def get_intersect(a1y, a1x, a2y, a2x, b1y, b1x, b2y, b2x):
    l1y = a1x - a2x
    l1x = a2y - a1y
    l1z = a1y * a2x - a1x * a2y
    
    l2y = b1x - b2x
    l2x = b2y - b1y
    l2z = b1y * b2x - b1x * b2y
    
    y = l1x * l2z - l1z * l2x
    x = l1z * l2y - l1y * l2z
    z = l1y * l2x - l1x * l2y
    
    
    if z == 0:  # lines are parallel
        return 0

    xi, yi = x / z, y / z
    
    # Check if intersection point lies outside the line segments' boundaries
    if (xi < max(min(a1x, a2x), min(b1x, b2x)) or
        xi > min(max(a1x, a2x), max(b1x, b2x)) or
        yi < max(min(a1y, a2y), min(b1y, b2y)) or
        yi > min(max(a1y, a2y), max(b1y, b2y))):
        return 0
    
    return 1


def Distplan(y, x, yE, xE):
    return np.sqrt((y - yE) * (y - yE) + (x - xE) * (x - xE))


def connect2(yc, xc, y, x):
    d0 = y - yc
    d1 = x - xc
    sign = 1
    
    if abs(d0) > abs(d1): 
        if d0 < 0:
            sign = -1
        ys = np.arange(yc, y + sign, sign, dtype=np.int32)  
        if d1 == 0:
            xs = np.ones_like(ys, dtype=np.int32) * xc
        else:
            xs = np.int32(np.arange(xc * abs(d0) + np.floor(abs(d0) / 2),
                           xc * abs(d0) + np.floor(abs(d0) / 2) + (abs(d0) + 1) * d1,
                           d1, dtype=np.int32) / abs(d0))
    else:
        if d1 < 0:
            sign = -1
        xs = np.arange(xc, x + sign, sign, dtype=np.int32)
        if d0 == 0:            
            ys = np.ones_like(xs, dtype=np.int32) * yc
        else:
            ys = np.int32(np.arange(yc * abs(d1) + np.floor(abs(d1) / 2),
                           yc * abs(d1) + np.floor(abs(d1) / 2) + (abs(d1) + 1) * d0, 
                           d0, dtype=np.int32) / abs(d1))
    
    return ys, xs


def check_profile(yc, xc, y, x, slope_perc, dtm, Csize, max_diff_z, Obs, Obs2, Ls, Lmax_ab_sl):
    ys, xs = connect2(yc, xc, y, x)
    test = 1
    nbpix = ys.shape[0]
    i = 0
    sumobs2 = 0
    newLsl = Ls
    z = 0
    zline = 0
    Dhor = 0
    zo = dtm[yc, xc]
    diffz = 0

    for i in range(nbpix):
        if Obs[ys[i], xs[i]] > 0:
            test = 0
            break
        Dhor = np.sqrt((xs[i] - xc) * (xs[i] - xc) + (ys[i] - yc) * (ys[i] - yc)) * Csize
        if i > 0:
            sumobs2 += Obs2[ys[i], xs[i]]
        z = dtm[ys[i], xs[i]]
        zline = slope_perc / 100. * Dhor + zo
        diffz = max(diffz, abs(zline - z))
        if diffz > max_diff_z:
            test = 0
            break
    if test:
        newLsl += min(sumobs2 * Csize, Dhor)
        if newLsl > Lmax_ab_sl:
            test = 0
    
    return test, newLsl


def diffz_prop_L(max_diff_z, D_neighborhood, L):
    return max_diff_z * L / D_neighborhood


def build_Tab_neibs(newObs, dtm, azimuts, dists_index, coords, min_slope, max_slope, nbpix):
    nrows, ncols = dtm.shape
    nbneig = azimuts.shape[0]
    
    IdPix = np.ones_like(dtm, dtype=np.int32) * -1
    IdVois = np.zeros((nbpix, nbneig), dtype=np.uint16)
    Slope = np.ones((nbpix, nbneig), dtype=np.int16) * -9999
    Id = np.ones((nbpix, nbneig), dtype=np.int32) * -9999
    Tab_corresp = np.zeros((nbpix, 3), dtype=np.uint16)
    
    ind = 0
    for y in range(nrows):
        for x in range(ncols):
            if newObs[y, x] == 0:
                IdPix[y, x] = ind
                Tab_corresp[ind, 0] = y
                Tab_corresp[ind, 1] = x
                ind += 1
                
    for ind in range(nbpix):  
        y = Tab_corresp[ind, 0]
        x = Tab_corresp[ind, 1]
        nbok = 0
        z = dtm[y, x]
        for i in range(nbneig):
            y1 = y + coords[i, 0]
            x1 = x + coords[i, 1]
            
            if y1 < 0 or y1 >= nrows or x1 < 0 or x1 >= ncols:
                continue                    
            if newObs[y1, x1]:
                continue
            if y1 == y and x1 == x:
                continue
            z1 = dtm[y1, x1]
            deltaH = z1 - z 
            D = dists_index[i]
            sl = deltaH / D * 100
            abssl = abs(sl)                  
            if abssl >= min_slope and abssl <= max_slope:
                IdVois[ind, nbok] = i
                Id[ind, nbok] = IdPix[y1, x1]
                sign = 1
                if sl < 0:
                    sign = -1
                Slope[ind, nbok] = int(abssl * 100 + 0.5) * sign
                nbok += 1
        Tab_corresp[ind, 2] = nbok
            
    return IdVois, Id, Tab_corresp, IdPix, Slope


def calc_init(idcurrent, Id, IdVois, Slope, Best, Tab_corresp, Az, Dist, newObs, Obs2, Dist_to_End, dtm, Csize, max_diff_z, D_neighborhood, Lmax_ab_sl, take_dtoend, yE, xE, mindist_to_end):
    xc = Tab_corresp[idcurrent, 1]
    yc = Tab_corresp[idcurrent, 0]
    nbvois = Tab_corresp[idcurrent, 2]
    add_to_frontier = np.zeros(nbvois, dtype=np.int32)
    nbok = 0
    
    for neib in range(nbvois):
        idvois = Id[idcurrent, neib]
        D = Dist[IdVois[idcurrent, neib]]
        y = Tab_corresp[idvois, 0]
        x = Tab_corresp[idvois, 1]
        
        if newObs[y, x]:
            continue
        
        D = Dist[IdVois[idcurrent, neib]]
        Azimut = Az[IdVois[idcurrent, neib]]
        slope_perc = Slope[idcurrent, neib] / 100.

        # Assuming check_profile function is defined elsewhere
        test_prof, newLsl = check_profile(yc, xc, y, x, slope_perc, dtm, Csize,
                                           diffz_prop_L(max_diff_z, D_neighborhood, D),
                                           newObs, Obs2, 0, Lmax_ab_sl)
        if not test_prof:
            continue

        if take_dtoend:
            D_to_cp = Dist_to_End[y, x]
        else:
            D_to_cp = Distplan(y, x, yE, xE) * Csize

        add_to_frontier[nbok] = idvois
        nbok += 1
        Best[idvois, 0] = idvois
        Best[idvois, 1] = D + newLsl
        Best[idvois, 2] = D
        Best[idvois, 3] = slope_perc
        Best[idvois, 4] = Azimut
        Best[idvois, 5] = idcurrent
        Best[idvois, 6] = 10 * D_neighborhood
        Best[idvois, 7] = newLsl
        Best[idvois, 8] = 1
        Best[idvois, 9] = D_to_cp

        mindist_to_end = min(mindist_to_end, D_to_cp)
    
    return Best, add_to_frontier[:nbok], mindist_to_end


def get_pix_bufgoal_and_update(Best, Tab_corresp, bufgoal, start, Csize, yE, xE):    
    nbmax = (2 * int(bufgoal / Csize + 0.5) + 1) * (2 * int(bufgoal / Csize + 0.5) + 1)
    nbval = Best.shape[0]
    add_to_frontier = np.zeros((nbmax,), dtype=np.int32)  
    keep = np.zeros((nbval,), dtype=np.uint8)
    
    j = 0
    
    for i in range(nbval):
        if Best[i, 0] < 0:
            continue
        if Best[i, 9] <= bufgoal:
            add_to_frontier[j] = i            
            j += 1
            current = i
            # mark pixel from as 1
            while current != start:
                if keep[current] == 1:
                    break
                keep[current] = 1
                current = int(Best[current, 5])
        y = Tab_corresp[i, 0]
        x = Tab_corresp[i, 1]
        Best[i, 9] = Distplan(y, x, yE, xE) * Csize  
    
    return Best, add_to_frontier[0:j], keep


def basic_calc(idcurrent, Id, IdVois, Slope, Best, Tab_corresp, Az, Dist, newObs, Obs2,
               Dist_to_End, dtm, LocSlope, Csize, max_diff_z, D_neighborhood, Lmax_ab_sl,
               take_dtoend, yE, xE, mindist_to_end, prop_sl_max, angle_hairpin, Radius,
               penalty_xy, penalty_z, max_slope_change, max_hairpin_angle,modhair=1.5):

    xc = Tab_corresp[idcurrent, 1]
    yc = Tab_corresp[idcurrent, 0]
    nbptbef = int(Best[idcurrent, 8])
    nbvois = Tab_corresp[idcurrent, 2]
    add_to_frontier = np.zeros((nbvois,), dtype=np.int32)
    nbok = 0

    for neib in range(nbvois):
        idvois = Id[idcurrent, neib]
        D = Dist[IdVois[idcurrent, neib]]
        if Best[idvois, 1] < Best[idcurrent, 1] + D:
            continue
        y = Tab_corresp[idvois, 0]
        x = Tab_corresp[idvois, 1]
        if newObs[y, x]:
            continue
        if idvois == Best[idcurrent, 5]:
            continue
        difangle2, hairpin = 0, 0
        Azimut = Az[IdVois[idcurrent, neib]]
        slope_perc = Slope[idcurrent, neib] / 100.
        difangle = diff_az(Azimut, Best[idcurrent, 4])
        if difangle > max_hairpin_angle:
            continue
        if difangle > angle_hairpin:
            if LocSlope > prop_sl_max:
                continue
            hairpin = 1
        if nbptbef > 1 and not hairpin:
            idfrom = int(Best[idcurrent, 5])
            Dcurrent = Best[idcurrent, 2] - Best[idfrom, 2]
            difangle2 = diff_az(Azimut, Best[idfrom, 4])
            if Dcurrent <= 2 * Radius and difangle2 > angle_hairpin:
                if LocSlope > prop_sl_max:
                    continue
                ycen = 0.5 * (yc + Tab_corresp[idfrom, 0])
                xcen = 0.5 * (xc + Tab_corresp[idfrom, 1])
                idfrom2 = int(Best[idfrom, 5])
                a2y = Tab_corresp[idfrom2, 0]
                a2x = Tab_corresp[idfrom2, 1]
                az1 = calculate_azimut(a2x, a2y, xcen, ycen)
                az2 = calculate_azimut(xcen, ycen, x, y)
                difangle2 = diff_az(az1, az2)
                if difangle2 > max_hairpin_angle:
                    continue
                hairpin = 1
        if hairpin and Best[idcurrent, 6] <= 2 * modhair * Radius:
            continue
        if nbptbef > 1:
            inter = 0
            i = 1
            idfrom = int(Best[idcurrent, 5])
            while i < nbptbef:
                a1y = Tab_corresp[idfrom, 0]
                a1x = Tab_corresp[idfrom, 1]
                idfrom = int(Best[idfrom, 5])
                a2y = Tab_corresp[idfrom, 0]
                a2x = Tab_corresp[idfrom, 1]
                if get_intersect(a1y, a1x, a2y, a2x, yc, xc, y, x):
                    inter = 1
                    break
                i += 1
            if inter:
                continue
        penalty_dir = penalty_xy * (max(difangle, difangle2) / angle_hairpin) ** 2
        difslope = abs(Best[idcurrent, 3] - slope_perc)
        penalty_slope = penalty_z * (difslope / max_slope_change) ** 2
        test_prof, newLsl = check_profile(yc, xc, y, x, slope_perc, dtm, Csize,
                                           diffz_prop_L(max_diff_z, D_neighborhood, D),
                                           newObs, Obs2, Best[idcurrent, 7], Lmax_ab_sl)
        if not test_prof:
            continue
        new_cost = (Best[idcurrent, 1] + D + penalty_dir + penalty_slope + newLsl - Best[idcurrent, 7])
        if hairpin:
            new_cost += 100 * (LocSlope / prop_sl_max) ** 2
        if take_dtoend:
            D_to_cp = Dist_to_End[y, x]
        else:
            D_to_cp = Distplan(y, x, yE, xE) * Csize
        if Best[idvois, 1] > new_cost:
            add_to_frontier[nbok] = idvois
            nbok += 1
            Best[idvois, 0] = idvois
            Best[idvois, 1] = new_cost
            Best[idvois, 2] = Best[idcurrent, 2] + D
            Best[idvois, 3] = slope_perc
            Best[idvois, 4] = Azimut
            Best[idvois, 5] = idcurrent
            Best[idvois, 7] = newLsl
            Best[idvois, 8] = Best[idcurrent, 8] + 1
            Best[idvois, 9] = D_to_cp
            Best[idvois, 10] = hairpin
            Best[idvois, 6] = 10 * D_neighborhood
            if hairpin:
                Best[idvois, 6] = min(Best[idvois, 6], D)
            i = 1
            idfrom = idcurrent
            while i < nbptbef - 1 and Best[idvois, 6] >= 2 * modhair * Radius:
                idfrom2 = int(Best[idfrom, 5])
                if Best[idfrom, 10]:
                    a1y = Tab_corresp[idfrom2, 0]
                    a1x = Tab_corresp[idfrom2, 1]
                    Best[idvois, 6] = min(Best[idvois, 6], Distplan(y, x, a1y, a1x) * Csize)
                idfrom = idfrom2
                i += 1
            mindist_to_end = min(mindist_to_end, D_to_cp)
    
    return Best, add_to_frontier[0:nbok], mindist_to_end


def calcul_distance_de_cout(yE, xE, zone_rast, Csize, Max_distance=100000):
    coords = np.array([[-1, -1], [0, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]], dtype=np.int8)
    nbneig = coords.shape[0]
    nline, ncol = zone_rast.shape
    dists_index = np.zeros((nbneig,), dtype=np.float32)

    Out_distance = np.ones_like(zone_rast, dtype=np.float32) * Max_distance
    Inds = np.ones((nline * ncol, 2), dtype=np.int32) * -9999

    for j in range(nbneig):
        dists_index[j] = np.sqrt(coords[j, 0] * coords[j, 0] + coords[j, 1] * coords[j, 1]) * Csize

    Out_distance[yE, xE] = 0
    i = 0
    for j in range(nbneig):
        y = coords[j, 0] + yE
        x = coords[j, 1] + xE
        if y<0 or y>=nline or x<0 or x>=ncol:
            if zone_rast[y, x] == 1:
                Dist = dists_index[j]
                if Out_distance[y, x] > Dist:
                    Out_distance[y, x] = Dist
                    Inds[i, 0], Inds[i, 1] = y, x
                    i += 1

    while i > 0:
        Indsbis = np.copy(Inds[0:i])
        nbinds = i
        i = 0
        for idpix in range(nbinds):
            y1, x1 = Indsbis[idpix, 0], Indsbis[idpix, 1]
            dist_ac = Out_distance[y1, x1]
            for j in range(nbneig):
                y = coords[j, 0] + y1
                x = coords[j, 1] + x1
                if y<0 or y>=nline or x<0 or x>=ncol:
                    if zone_rast[y, x] == 1:
                        dist_ac = Out_distance[y1, x1] + dists_index[j]
                        if Out_distance[y, x] > dist_ac:
                            Out_distance[y, x] = dist_ac
                            Inds[i, 0], Inds[i, 1] = y, x
                            i += 1

    for y in range(nline):
        for x in range(ncol):
            if Out_distance[y, x] == Max_distance:
                Out_distance[y, x] = -9999
          
    return Out_distance


def save_param_file(Wspace,Dtm_file,Obs_Dir,Waypoints_file,Property_file,Result_Dir,
                    trans_slope_all,trans_slope_hairpin,min_slope,max_slope,penalty_xy,
                    penalty_z,D_neighborhood,max_diff_z,angle_hairpin,Lmax_ab_sl,Rspace,Radius):
    
    """Save simulation parameters to a NumPy file.

    :param workspace: Workspace directory.
    :type workspace: str

    :param dtm_file: Path to the digital terrain model (DTM) file.
    :type dtm_file: str

    :param obs_dir: Directory containing obstacle files.
    :type obs_dir: str

    :param waypoints_file: Path to the waypoints file.
    :type waypoints_file: str

    :param property_file: Path to the property file.
    :type property_file: str

    :param result_dir: Directory to save simulation results.
    :type result_dir: str

    :param trans_slope_all: Maximum slope allowed in traverse direction.
    :type trans_slope_all: float

    :param trans_slope_hairpin: Maximum slope allowed for hairpin turns.
    :type trans_slope_hairpin: float

    :param min_slope: Minimum slope allowed.
    :type min_slope: float

    :param max_slope: Maximum slope allowed.
    :type max_slope: float

    :param penalty_xy: Penalty for changing direction.
    :type penalty_xy: float

    :param penalty_z: Penalty for changing longitudinal slope.
    :type penalty_z: float

    :param d_neighborhood: Distance around a pixel to consider for analysis.
    :type d_neighborhood: float

    :param max_diff_z: Maximum allowable difference between terrain altitude and
                       theoretical track altitude.
    :type max_diff_z: float

    :param angle_hairpin: Angle beyond which a turn is considered a hairpin turn.
    :type angle_hairpin: float

    :param lmax_ab_sl: Maximum cumulative length with traverse slope greater than
                       maximum traverse slope.
    :type lmax_ab_sl: float

    :param rspace: Path to save the simulation parameters.
    :type rspace: str

    :param radius: Turning radius applied to hairpin turns.
    :type radius: float

    :raises: None

    :rtype: None
    """
    parameters = {
        'Workspace': Wspace,
        'DTM_File': Dtm_file,
        'Obs_Dir': Obs_Dir,
        'Waypoints_File': Waypoints_file,
        'Property_File': Property_file,
        'Result_Dir': Result_Dir,
        'Trans_Slope_All': trans_slope_all,
        'Trans_Slope_Hairpin': trans_slope_hairpin,
        'Min_Slope': min_slope,
        'Max_Slope': max_slope,
        'Penalty_XY': penalty_xy,
        'Penalty_Z': penalty_z,
        'D_Neighborhood': D_neighborhood,
        'Max_Diff_Z': max_diff_z,
        'Angle_Hairpin': angle_hairpin,
        'Lmax_Ab_Sl': Lmax_ab_sl,
        'Rspace': Rspace,
        'Radius': Radius
    }

    np.save(Rspace + "SylvaRoaD_param.npy", parameters)


def build_NeibTable(D_neighborhood,Csize,dtm,Obs,min_slope,max_slope):
    
    """ Description
    :type D_neighborhood:
    :param D_neighborhood:

    :type Csize:
    :param Csize:

    :type dtm:
    :param dtm:

    :type Obs:
    :param Obs:

    :type min_slope:
    :param min_slope:

    :type max_slope:
    :param max_slope:

    :raises:

    :rtype:
    """
    nbpix_neighborhood=int(D_neighborhood/Csize+0.5)
    x, y = np.meshgrid(np.arange(-nbpix_neighborhood, nbpix_neighborhood+1, dtype=int), 
                      np.arange(-nbpix_neighborhood, nbpix_neighborhood+1, dtype=int))
    coords = np.vstack((np.ndarray.flatten(x), np.ndarray.flatten(y))).T    
    coords = np.delete(coords, [nbpix_neighborhood*(2*nbpix_neighborhood+2)],axis=0)
    azimuts = np.copy(coords[:,0])*0.
    for i,neig in enumerate(coords):
        azimuts[i]=calculate_azimut(0,0,neig[1],-neig[0])
    dists_index = np.sqrt(np.sum(np.square(coords),axis=1))*Csize
    
    #keep only neibourg within distance
    tp = dists_index <= D_neighborhood
    coords=coords[tp]
    azimuts=np.float32(azimuts[tp])
    dists_index=np.float32(dists_index[tp])
    
    IdVois, Id, Tab_corresp,IdPix ,Slope =  build_Tab_neibs(Obs,dtm,azimuts,
                                                              dists_index,coords,
                                                              min_slope,max_slope,
                                                              np.sum(Obs==0))
    
    nbneibmax = np.max(Tab_corresp[:,2])
    
    return IdVois[:,:nbneibmax],Id[:,:nbneibmax],Tab_corresp,IdPix,Slope[:,:nbneibmax],dists_index,azimuts


def build_radius(R):
    
    """Builds coordinates around a circle with radius R.

    :param R: Radius of the circle.
    :type R: float

    :return: Array of coordinates around the circle, where each row represents a point.
    :rtype: numpy.ndarray

    :raises: None
    """
    coords =np.zeros((360,3),dtype=np.float) 
    for pol in range(0,360):
        coords[pol,0]=pol
        coords[pol,1]= R*np.cos(np.radians((pol)%360))#x
        coords[pol,2]= R*np.sin(np.radians((pol)%360))#y
    return coords


def calculate_polar(x1,y1,x2,y2):
    
    """Calculates the azimuth between two points from their coordinates.

    :param x1: x-coordinate of the first point.
    :type x1: float
    :param y1: y-coordinate of the first point.
    :type y1: float
    :param x2: x-coordinate of the second point.
    :type x2: float
    :param y2: y-coordinate of the second point.
    :type y2: float

    :return: Azimuth angle between the two points in degrees.
    :rtype: float

    :raises: None
    """
    DX = x2-x1
    DY = y2-y1
    Deuc = np.sqrt(DX**2+DY**2)
    if x2>x1:Fact=1
    else:Fact=-1
    Angle = np.degrees(np.arccos(DY/Deuc))
    Angle *=Fact
    az = Angle%360
    return conv_az_to_polar(az)
